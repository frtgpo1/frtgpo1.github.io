SCOPE

Root Scope (window)

window.method();
window.varMethod();
// window.letMethod(); 		nicht vorhanden
// window.constMethod();	nicht vorhanden

console.log(varVariable);
console.log(letVariable);
console.log(constVariable);

console.log(window.varVariable);
// console.log(window.letVariable);		nicht vorhanden
// console.log(window.constVariable);	nicht vorhanden


// Function Scope
var fun = 5;
funFunction = () => {
	// child scope
	var fun = 10;
}
funnierFunction = () => {
	// asks funnierFunction -> no => asks parent -> yes
	fun = 10;
}


ADVANCED FUNCTIONS

Closures
// Child Scope hat immer Zugriff auf den Parent Scope. Parent Scopt hat niemals Zugriff auf die Children.
const first = () => {
    const greet = 'Hi';
    const second = () => {
        alert(greet);
    }
    return second;
}
const newFunc = first();
newFunc();		// 'Hi'


Currying
// Der Prozess, eine Funktion, die mit mehreren Parametern gleichzeitig aufgerufen wird, 
// umzustrukturieren, so dass sie jeden Paramter nacheinander annimmt.
// Wofür? Erweiterbarkeit.
const multiply = (a, b) => a * b;               // multiply(3, 4);
const curriedMultiply = (a) => (b) => a * b;    // curriedMultiply(3)(4);
// Anders geschrieben:
function curriedMultiply2(a) {
    return function(b) {
        return a * b;
    }
}
// Erweiterbarkeit Beispiel:
const multiplyByFive = curriedMultiply(5);
const multiplyByTen = curriedMultiply(10);


Compose
// Zusammenführen von 2 Funktionen zu einer 3.,
// wobei der Output der einen Funktion der Input der anderen Funktion ist.
const compose = (f, g) => (a) => f(g(a));
const function myFunc (f,g) {
	return function secondFunc () {
		return
	}
}

//Beispiel-Argument:
const sum = (number) => number + 1;

//Beispiel-Anwendung
compose(sum, sum)(5);   // 10


// Eigenes Beispiel zum Verständnis
const meineComposeFunktion = (x, y) => (parameter) => x(y(parameter));
const square = (number) => number * number;
const makeText = (result) => `The result is ${result}.`
meineComposeFunktion(makeText, square)(5);  // The result is 25.


// Gleiches Ergebnis mit Callback-Funktionen, aber dann wohl nicht so erweiterbar.
const meineCallbackFunktion = (number, callback1, callback2) => {
    const result = callback1(number)
    return callback2(result);
}
const result = meineCallbackFunktion(5, square, makeText);
console.log(result);


ADVANCED ARRAYS
// Die folgenden Funktionen sind meist nützlich, wenn man über Arrays iteriert.

const array = [1, 2, 10, 16];
const newArray = [];

// Läuft nur die Funktion durch, was immer darin steht. Vllt Side Effects. Vllt kein Return.
array.forEach(value => newArray.push(value * 2));	        // Side Effect


// 3 Neue Funktionen
// Pure Function
// Machen die gegebene Operation mit jedem Element des alten Arrays und verändern es nicht.
// Geben neues Array zurück.
// Verlangen einen Return Wert.

const mappedArray = array.map(value => value * 2);             // Pure Function

// Filtert jeden Wert nach einer Bedingung.
// True - kommt in neues Array. False - nicht.
const filteredArray = array.filter(value => value > 5);     // Pure Function

// Name verwirrend. Einfach nehmen, wenn beim Iterieren vorheriger Wert benötigt wird.
// acc  - accumulator - Wert des vorherigen Elements
// 0    - Startwert (Nicht Startelement)
const reducedArray = array.reduce((acc, value) => {acc + value}, 0);       // Pure Function





ADVANCED OBJECTS
Context vs. Scope
// Scope - In was für einer Funktion befinde ich mich?
// Context(this) - In was für einem OBJEKT befinde ich mich?
// Kontext - was steht links vor dem Punkt (alert = window.alert)
// ES6 Funktionen sind da anders..

const logSomething = () => console.log(this);					// window

const objectNewSyntax = { log: () => console.log(this) };		// window 

const objectOldSyntax = {
	a: function() {
		console.log(this);										// {objectOldSyntax: f}
	}
}



Instanciation
// Klassen und Vererbung

class Player {
	constructor(name, type) {
		console.log("player", this);		// this = Player / this = Mage
		this.name = name;
		this.type = type;
	}

	greet() {
		console.log(`Hi, I am ${this.name} and I am a ${this.type}`);
	}
}

class Mage extends Player {
	constructor(name, type) {
		super(name, type);							// Übergebe die Argumente des Base Kontruktors. Muss direkt im Child-Konstruktor aufgerufen werden.
		console.log("mage", this);					// this = Mage
	}

	play() {
		console.log("Whee, I am a wizz!");
	}
}

const shelly = new Mage("Shelly", "Frost Mage");	// player Mage, mage Mage
const john = new Mage("John", "Arcan Mage");		// player Mage, mage Mage
const player = new Player("Horst", "Object");		// player Player 




ES7
Includes
'Helloooo'.includes('o');	// true

const pets = ['cat', 'dog', 'bat'];
pets.includes('dog');		// true
pets.includes('bird');		// false
pets.includes('bir');		// false

Potency
const square = (x) => x**2	// x^2
const cube = (x) => x**3	// x^3


// ES8
// String Padding
"Turtle".padStart(10);      // "    Turtle"
"Turtle".padEnd(10);        // "Turtle    "

// Trailing Commas in functions, parameter lists and cults(oder so)
const fun = (a,b,c,d,) => console.log(a);   // Komma ist valide..
fun(3); // 3



// Object Functions like Array Functions
let obj = {
    username0: 'Santa',
    username1: 'Rudolf',
    username3: 'Mr. Grinch'
}
// Alt
// hat das Objekt wie ein Array behaldelt, damit man forEach nutzen konnte.
// so kann man den Key und den Value von allem im Objekt nutzen.
Object.keys(obj).forEach((key, index) => {
    console.log(`Key: ${key}, Object: ${obj[key]}`);
});

// Neu
// Damit lassen sich alle Array Funktionen auch für Objekte nutzen!!!
// Object.values iteriert über alle Values im Objekt.
Object.values(obj).forEach(value => console.log(value));
// Object.entries iteriert über alle Einträge (Key-Value-Paare) im Objekt.
Object.entries(obj).forEach(value => console.log(value));
const myMappedArray = Object.entries(obj).map((value) => `${value} homo Junge`);
const myFilteredArray = Object.values(obj).filter(value => value.length > 5);
const myReducedArrayString = Object.values(obj).reduce((acc, value) => `${acc} ${value}`);





// Async Await
Eigenes Video später






DEBUGGING
// Wenn die JavaScript Engine (z.B. im Browser) auf 'debugger' stößt, stoppt sie dort.
const flattened = [[0, 1], [2, 3], [4, 5]].reduce(
	(a, b) => {
		debugger;			// Debug-Keyword
		return a.concat(b);
}, []);





HOW DOES JAVASCRIPT WORK

A Program
-allocates Memory 		(Memory Heap)
-read and execute code 	(Call Stack)


JavaScript Engine consists of 2 parts:
-Memory Heap 	// Weißt einem begrenzten Speicher Variablen und Funktionen zu.
-Call Stack 	// Stapelt die Funktionen zum Aufrufen und entfernt sie, wenn sie fertig sind von innen nach außen ==> }
				// First-In-Last-Out


JavaScript is a Single-Threaded language, that can be Non-Blocking;
Single-Threaded - EIN Call Stack
Multi-Threaded	- Mehrere Call Stacks: Dinge können gleichzeitig passieren.


Synchrone Programmierung	- 	Single Threaded 	-	Ein Call Stack
Asynchrone Programmierung	- 	Multi Threaded 		- 	Mehrere Call Stacks

// Bei synchroner Programmierung wird ganz sicher Zeile für Zeile ausgeführt.

// Stack Overflow Beispiel durch Recursion ohne die Funktion wieder "abzubauen".
// Stack wird immer voller mit jedem mal, in dem die Funktion sich aufruft und wird niemals "abgebaut".
const foo = () =>  {
	foo();
}





// Non-Blocking
/* 	Asynchronous Behaviour
	Es wird nicht wie bei synchronem Verhalten darauf gewartet, 
	dass jede Zeile fertig wird (Bildverarbeitung, API Requests würden lange dauern).
	Bestimmte Prozesse 
*/

// Diagramm zum Verständnis
https://www.udemy.com/the-complete-web-developer-in-2018/learn/v4/t/lecture/9427570?start=930



// CALL STACK


// WEB API


// CALLBACK QUEUE


// EVENT LOOP


console.log(1);
setTimeout(() => {
	console.log(2);
}, 2000);
console.log(3);
						// 1
						// 3
						// 2

Mit setTimeout() nimmt die Web API die Funktion aus dem Call Stack heraus und packt sie 2 Sekunden später in die Callback-Queue.
Der Event Loop checkt ständig nach, ob der Call Stack leer ist und falls er leer ist, guckt er, ob es Callbacks gibt und 
packt diesen Callback dann aus der Callback-Queue in den Call Stack, bis dieser vom Call Stack bearbeitet und dann gelöscht wurde.

Event Listener geben ebenfalls Callback Functions in die Callback-Queue.

Also:

console.log(1);
setTimeout(() => {
	console.log(2);
}, 0);					//<== 0 Timeout wird trotzdem GANZ AM ENDE aufgerufen.
console.log(3);
console.log(3);
console.log(3);
console.log(3);
console.log(3);

/*
JavaScript is a Single-Threaded language, that can be Non-Blocking;
It has ONE Call Stack and it does one thing at a time.
In order to not-block the single thread it can be asynchronous with callback functions.
*/






MODULES

Dependency Resolution - Die Kunst, Dependencies einzubinden (oder so)
z.B. auch bei NuGet packages
-Welche Version der Dependency? 	(es gibt automatisierte Regeln dafür)
-Welche Reihenfolge der Einbindung?	(Was hängt wovon ab?)

History:
Inline Script   - Alles auf global scope + SOC Widerspruch.
Script Tags 	- Alles auf global scope + Reihenfolge der Einbindung fragil.
IIFE 			- Nicht mehr global scope, aber Reihenfolge der Einbindung fragil.
Browserify		- Bundler -> eine Script Einbindung des Bundles + 'require' Syntax.	

Webpack2 + ES6
// auch Bundler
// liefert den Dependency Tree von Funktionen in Modulen.
// Beispiel:

// JS1
export const add = (a, b) => a + b;		// so
export default function add() {			// oder so
	return a + b;
}

// JS2
import { add } from './add';
import add from './add';